SET TERMOUT OFF FEEDBACK OFF VERIFY OFF PAGES 500 LINES 250 UNDERLINE '~'

DEFINE P1=&1.
DEFINE SUMMARY=&2.

COL SID              FORMAT 99             HEAD "Sid"
COL ADDRESS          FORMAT A18            HEAD "Address" JUST R
COL CHILD_ADDRESS    FORMAT A18            HEAD "Child Address" JUST L
COL PLAN_HASH_VALUE  FORMAT 99999999999    HEAD "Plan Hash" JUST R
COL HASH_VALUE       FORMAT 99999999999    HEAD "Hash Value" JUST R
COL ROWS_PROCESSED   FORMAT 999G999G999    HEAD "Linhas|Processadas" JUST R
COL DISK_READS       FORMAT A9             HEAD "Leituras|Físicas" JUST R
COL DR_EXEC          FORMAT A9             HEAD "Leituras|Fís./Exec" JUST R
COL BUFFER_GETS      FORMAT A9             HEAD "Leituras|Lógicas" JUST R
COL BG_EXEC          FORMAT A9             HEAD "Leituras|Lóg./Exec" JUST R
COL USERS_OPENING    FORMAT A9             HEAD "Users|Open/Exec" JUST R
COL EXECUTIONS       FORMAT 99G999G999     HEAD "Execs|Total"
COL SORTS            FORMAT 999G999        HEAD "Sorts" NOPRINT
COL VERSIONS         FORMAT A9             HEAD "Versions|Tot/Open"  JUST R
COL CPU_TIME         FORMAT A9             HEAD 'CPU Time|msecs' JUST R
COL CPU_TIME_BY_EXEC FORMAT A10            HEAD 'CPU Time|msecs/Exec' JUST R
COL ELA_TIME_BY_EXEC FORMAT A12            HEAD 'Elapsed Time|msecs/Exec' JUST R
COL ELAPSED_TIME     FORMAT A12            HEAD 'Elapsed Time|msecs' JUST R
COL BIND_POS         FORMAT 999            HEAD 'Pos'
COL BIND_VAR         FORMAT A20            HEAD 'Bind name' TRUNC
COL BIND_VALUE       FORMAT A100           HEAD 'Bind value' TRUNC
COL PARSING_USER     FORMAT A20            HEAD "Parsing User" TRUNC

COL P_HASH NEW_VALUE P_HASH NOPRINT
COL P_ADDR NEW_VALUE P_ADDR NOPRINT
COL P_CHILD_NUM NEW_VALUE P_CHILD_NUM NOPRINT
COL P_CHILD_ADDR NEW_VALUE P_CHILD_ADDR NOPRINT
COL P_SQL_ID NEW_VALUE P_SQL_ID NOPRINT
COL P_SQL_PATCH NEW_VALUE P_SQL_PATCH NOPRINT
COL P_SQL_PROFILE NEW_VALUE P_SQL_PROFILE NOPRINT
COL P_SQL_PLAN_BASELINE NEW_VALUE P_SQL_PLAN_BASELINE NOPRINT
COL P_OUTLINE_CATEGORY NEW_VALUE P_OUTLINE_CATEGORY NOPRINT

COL VERSAO NEW_VALUE P_VERSAO NOPRINT
COL QTCOPIAS NEW_VALUE P_QTCOPIAS NOPRINT
COL WHERE_CURSOR NEW_VALUE P_WHERE_CURSOR NOPRINT

-- DEFINE A CLUSULA WHERE
SELECT 
  CASE UPPER(SUBSTR( '&P1.',1,5))
    WHEN '' THEN '1=0'
    WHEN 'HASH=' THEN 'S.HASH_VALUE = ' || SUBSTR( '&P1.',6, LENGTH('&P1.')) || ''
    WHEN 'ADDR=' THEN 'S.ADDRESS = ''' || SUBSTR( '&P1.',6, LENGTH('&P1.')) || ''''
    WHEN 'CHLD=' THEN 'S.CHILD_ADDRESS = ''' || SUBSTR( '&P1.',6, LENGTH('&P1.')) || ''''
    ELSE 'S.SQL_ID = ''&P1.'''
  END WHERE_CURSOR
FROM DUAL
/

-- DEFINE QUAL DOS ENDEREÇOS DE MEMÓRIA SERÁ USADO (MARCARÁ COM *)
SELECT 
   TO_CHAR(S.HASH_VALUE) P_HASH
  ,S.SQL_ID P_SQL_ID
  ,S.ADDRESS P_ADDR
  ,S.CHILD_ADDRESS P_CHILD_ADDR
  ,S.SQL_PATCH P_SQL_PATCH
  ,S.SQL_PROFILE P_SQL_PROFILE
  ,S.SQL_PLAN_BASELINE P_SQL_PLAN_BASELINE
  ,S.OUTLINE_CATEGORY P_OUTLINE_CATEGORY
  ,DECODE( TRUNC( COUNT(*) / 100 ), 0, 0, COUNT(*) )  QTCOPIAS
  ,SUM(S.OPEN_VERSIONS)*1000 + SUM(S.USERS_OPENING)
  ,COUNT(*)
  ,MIN( S.CHILD_NUMBER ) P_CHILD_NUM
FROM GV$SQLAREA A
JOIN GV$SQL S ON ( A.ADDRESS = S.ADDRESS )
WHERE &P_WHERE_CURSOR.
GROUP BY 
   TO_CHAR(S.HASH_VALUE) 
  ,S.SQL_ID 
  ,S.ADDRESS 
  ,S.CHILD_ADDRESS
  ,S.SQL_PATCH 
  ,S.SQL_PROFILE 
  ,S.SQL_PLAN_BASELINE 
  ,S.OUTLINE_CATEGORY 
ORDER BY SUM(S.OPEN_VERSIONS)*1000 + SUM(S.USERS_OPENING) DESC FETCH FIRST 1 ROW ONLY
/

-- VERIFICA O NUMERO DE COPIAS E VERSÃO DA ROTINA PARA OBTER O PLANO - CASO O NUMERO SEJA MUITO GRANT NEM RETORNA O PLANO (PROBLEMAS DE PERFORMANCE)
SELECT DECODE( &P_QTCOPIAS., '-1', '1', '0', SUBSTR( VERSION, 1, INSTR(VERSION, '.')-1), '' ) VERSAO
FROM GV$INSTANCE
/

-- PARA DEBUG LIGAR O TERMOUT ABAIXO
SET TERMOUT OFF
PROMPT
PROMPT DEBUG P_SQL_ID: &P_SQL_ID.
PROMPT DEBUG HASH: &P_HASH.
PROMPT DEBUG ADDRESS: &P_ADDR.
PROMPT DEBUG P_CHILD_ADDR: &P_CHILD_ADDR.
PROMPT DEBUG WHERE_CURSOR &P_WHERE_CURSOR.
PROMPT DEBUG VERSAO = '&P_VERSAO.' COPIAS = &p_qtcopias.

-- COMEÇA A IMPRESSÃO DOS DADOS
SET TERMOUT ON

WITH GVS AS 
(
  SELECT
     S.INST_ID
    ,S.SQL_ID
    ,S.ADDRESS
    ,S.CHILD_ADDRESS
    ,S.PLAN_HASH_VALUE
    ,S.PARSING_SCHEMA_NAME
    ,COUNT(*) VERSION_COUNT
    ,SUM(S.OPEN_VERSIONS) OPEN_VERSIONS
    ,SUM(S.USERS_OPENING) USERS_OPENING
    ,SUM(S.USERS_EXECUTING) USERS_EXECUTING
    ,SUM(S.SORTS) SORTS 
    ,SUM(S.EXECUTIONS) EXECUTIONS
    ,SUM(S.ROWS_PROCESSED) ROWS_PROCESSED
    ,SUM(S.DISK_READS) DISK_READS
    ,SUM(S.BUFFER_GETS) BUFFER_GETS
    ,SUM(S.CPU_TIME/1000) CPU_TIME
    ,SUM(S.ELAPSED_TIME/1000) ELAPSED_TIME
  FROM GV$SQL S
  WHERE S.SQL_ID = '&P_SQL_ID.'
  GROUP BY 
     S.INST_ID
    ,S.SQL_ID
    ,S.ADDRESS
    ,S.CHILD_ADDRESS
    ,S.PLAN_HASH_VALUE
    ,S.PARSING_SCHEMA_NAME
   --HAVING SUM(S.USERS_OPENING) > 0
), GVSA AS (
  SELECT
     INST_ID
    ,SQL_ID
    ,ADDRESS
    ,CHILD_ADDRESS
    ,PLAN_HASH_VALUE
    ,PARSING_SCHEMA_NAME
    ,VERSION_COUNT
    ,OPEN_VERSIONS
    ,SORTS 
    ,EXECUTIONS
    ,ROWS_PROCESSED
    ,DISK_READS
    ,BUFFER_GETS
    ,CPU_TIME
    ,ELAPSED_TIME
    ,LPAD(VERSION_COUNT||'/'||OPEN_VERSIONS, 9, ' ') VERSIONS 
    ,LPAD(USERS_OPENING||'/'||USERS_EXECUTING, 9, ' ') USERS_OPENING
    ,ROUND(DISK_READS/DECODE(EXECUTIONS,0,1,EXECUTIONS),2) DR_EXEC
    ,ROUND(BUFFER_GETS/DECODE(EXECUTIONS,0,1,EXECUTIONS),2) BG_EXEC
    ,ROUND(CPU_TIME/DECODE(EXECUTIONS,0,1,EXECUTIONS),2) CPU_TIME_BY_EXEC
    ,ROUND(ELAPSED_TIME/DECODE(EXECUTIONS,0,1,EXECUTIONS),2) ELA_TIME_BY_EXEC
  FROM GVS
)
SELECT DISTINCT
   S.INST_ID SID
  ,S.PARSING_SCHEMA_NAME PARSING_USER
  ,DECODE( S.CHILD_ADDRESS, '&P_CHILD_ADDR', '* ', '  ' ) || S.CHILD_ADDRESS CHILD_ADDRESS 
  ,S.PLAN_HASH_VALUE PLAN_HASH_VALUE
  ,S.EXECUTIONS
  ,LPAD(
     decode(sign(1e+12-S.CPU_TIME_BY_EXEC), -1, to_char(S.CPU_TIME_BY_EXEC/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.CPU_TIME_BY_EXEC), -1, to_char(S.CPU_TIME_BY_EXEC/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.CPU_TIME_BY_EXEC), -1, to_char(S.CPU_TIME_BY_EXEC/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.CPU_TIME_BY_EXEC, 'fm999g999g999' )  ) ) ), 10, ' ' ) CPU_TIME_BY_EXEC
  ,LPAD(
     decode(sign(1e+12-S.ELA_TIME_BY_EXEC), -1, to_char(S.ELA_TIME_BY_EXEC/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.ELA_TIME_BY_EXEC), -1, to_char(S.ELA_TIME_BY_EXEC/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.ELA_TIME_BY_EXEC), -1, to_char(S.ELA_TIME_BY_EXEC/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.ELA_TIME_BY_EXEC, 'fm999g999g999' )  ) ) ), 12, ' ' ) ELA_TIME_BY_EXEC
  ,LPAD(
     decode(sign(1e+12-S.BG_EXEC), -1, to_char(S.BG_EXEC/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.BG_EXEC), -1, to_char(S.BG_EXEC/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.BG_EXEC), -1, to_char(S.BG_EXEC/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.BG_EXEC, 'fm999g999g999' )  ) ) ), 9, ' ' ) BG_EXEC
  ,LPAD(
     decode(sign(1e+12-S.DR_EXEC), -1, to_char(S.DR_EXEC/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.DR_EXEC), -1, to_char(S.DR_EXEC/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.DR_EXEC), -1, to_char(S.DR_EXEC/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.DR_EXEC, 'fm999g999g999' )  ) ) ), 9, ' ' ) DR_EXEC
  ,S.SORTS
  ,S.ROWS_PROCESSED
  ,LPAD(
     decode(sign(1e+12-S.BUFFER_GETS), -1, to_char(S.BUFFER_GETS/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.BUFFER_GETS), -1, to_char(S.BUFFER_GETS/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.BUFFER_GETS), -1, to_char(S.BUFFER_GETS/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.BUFFER_GETS, 'fm999g999g999' )  ) ) ), 9, ' ' ) BUFFER_GETS
  ,LPAD(
     decode(sign(1e+12-S.DISK_READS), -1, to_char(S.DISK_READS/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.DISK_READS), -1, to_char(S.DISK_READS/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.DISK_READS), -1, to_char(S.DISK_READS/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.DISK_READS, 'fm999g999g999' )  ) ) ), 9, ' ' ) DISK_READS
  ,LPAD(
     decode(sign(1e+12-S.CPU_TIME), -1, to_char(S.CPU_TIME/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.CPU_TIME), -1, to_char(S.CPU_TIME/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.CPU_TIME), -1, to_char(S.CPU_TIME/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.CPU_TIME, 'fm999g999g999' )  ) ) ), 9, ' ' ) CPU_TIME
  ,LPAD(
     decode(sign(1e+12-S.ELAPSED_TIME), -1, to_char(S.ELAPSED_TIME/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.ELAPSED_TIME), -1, to_char(S.ELAPSED_TIME/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.ELAPSED_TIME), -1, to_char(S.ELAPSED_TIME/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.ELAPSED_TIME, 'fm999g999g999' )  ) ) ), 12, ' ' ) ELAPSED_TIME
  ,S.VERSIONS 
  ,S.USERS_OPENING
FROM GVSA S
WHERE S.SQL_ID = '&P_SQL_ID.'
ORDER BY sid 
/

SET SERVEROUT ON
PROMPT
DECLARE
  -- ESTE BLOCO SERVE PARA RECUPERAR O TEXTO DE UM SQL
  NLEN    PLS_INTEGER ;
  IDX     PLS_INTEGER := 0;
  NPOS    PLS_INTEGER := 0;
  V_TXT   VARCHAR2(32000) := '';
  V_LINHA VARCHAR2(300) := '';

  FUNCTION RESERVADA( L VARCHAR2 ) RETURN NUMBER
  IS
    TYPE T IS TABLE OF VARCHAR2(30);
    A T := T( 'WITH', 'UPDATE', 'INSERT', 'DELETE', 'SELECT', 'FROM', 'WHERE', 'GROUP BY', 'HAVING',
               'ORDER BY', 'START WITH', 'CONNECT BY', 'VALUES', 'SET' );
    P PLS_INTEGER;
  BEGIN
    RETURN 0; -- INIBE ESTA FUNCAO
    FOR I IN A.FIRST .. A.LAST LOOP
       P := INSTR( L, A(I) );
       IF P > 2 THEN
         RETURN P-1;
       END IF;
    END LOOP;
    RETURN 0;
  END;

  FUNCTION WORDBREAK( L VARCHAR2 ) RETURN NUMBER
  IS
    A VARCHAR2(40) := '.,.=.>.<.).+.-.*./.';
    N PLS_INTEGER := LENGTH( L );
  BEGIN
    -- RETURN LENGTH(L); -- INIBE ESTA FUNCAO
    IF INSTR( L, CHR(10) ) > 0 THEN
      RETURN INSTR( L, CHR(10) );
    ELSIF N < 120 THEN
      RETURN N;
    ELSE
      FOR I IN REVERSE 1 .. LENGTH(L) LOOP
        IF INSTR( A, '.'||SUBSTR( L, I, 1 )||'.' ) > 0 THEN
          RETURN I;
        END IF;
      END LOOP;
    END IF;
    RETURN N;
  END;

BEGIN

  IF &SUMMARY. THEN
    RETURN;
  END IF;

  DBMS_OUTPUT.PUT_LINE( 'Comando de SQL' );
  DBMS_OUTPUT.PUT_LINE( LPAD( '~', 169, '~' ) );

  FOR C IN
  (
    SELECT SQL_TEXT FROM GV$SQLTEXT_WITH_NEWLINES S
    WHERE ADDRESS = '&P_ADDR.'
    ORDER BY PIECE
  )
  LOOP
    V_TXT := V_TXT || C.SQL_TEXT;
  END LOOP;

  NLEN := LENGTH( V_TXT );

  WHILE IDX < NLEN LOOP

    V_LINHA := UPPER( SUBSTR( V_TXT, IDX+1, 169 ) );

    NPOS := RESERVADA( V_LINHA );

    IF NPOS = 0 THEN
      NPOS := WORDBREAK( V_LINHA );
    END IF;

    DBMS_OUTPUT.PUT_LINE( REPLACE(REPLACE(SUBSTR( V_TXT, IDX+1, NPOS ), CHR(10), '' ), CHR(13), '' ) );
    IDX := IDX + NPOS;

  END LOOP;

  IF LENGTH( V_TXT ) > 0 THEN
    DBMS_OUTPUT.PUT_LINE( '/' );
  ELSE
    DBMS_OUTPUT.PUT_LINE( 'Comando não encontrado!' );
  END IF;

END;
/

SET SERVEROUT OFF

PROMPT
PROMPT --- Bind Info
SELECT CHILD_ADDRESS, POSITION BIND_POS, NAME BIND_VAR, VALUE_STRING BIND_VALUE
FROM V$SQL_BIND_CAPTURE S
WHERE SQL_ID = '&P_SQL_ID.'
ORDER BY ADDRESS, CHILD_ADDRESS, POSITION FETCH FIRST 300 ROWS ONLY

/
PROMPT
PROMPT --- <End> Bind Info

SET PAGES 200 FEEDBACK 6 VERIFY ON UNDERLINE '-'

COL VERSAO CLEAR
COL QTCOPIAS CLEAR
COL ADDRESS CLEAR

UNDEFINE 1 P1 P_QTCOPIAS 

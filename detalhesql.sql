SET TERMOUT OFF FEEDBACK OFF VERIFY OFF PAGES 500 LINES 200 UNDERLINE '~'

DEFINE P1=&1.
COL SID              FORMAT 999
COL ADDRESS          FORMAT A18            HEAD "Address" JUST R
COL HASH_VALUE       FORMAT 99999999999    HEAD "Hash Value" JUST R 
COL ROWS_PROCESSED   FORMAT 999G999G999    HEAD "Linhas|Processadas" JUST R
COL DISK_READS       FORMAT 999G999G999    HEAD "Leituras|Físicas"
COL DR_EXEC          FORMAT 999G999G999    HEAD "Leituras|Físicas/Exec"
COL BUFFER_GETS      FORMAT 99G999G999G999 HEAD "Leituras|Lógicas"
COL BG_EXEC          FORMAT 99G999G999G999 HEAD "Leituras|Lógicas/Exec"
COL SHARABLE_MEM     FORMAT 99G999G999     HEAD "Memória|Compartilhada"
COL USERS_OPENING    FORMAT A9             HEAD "Users|Open/Exec" JUST R
COL EXECUTIONS       FORMAT 99G999G999     HEAD "Execs|Total"
COL SORTS            FORMAT 999G999        HEAD "Sorts" NOPRINT
COL CHILDS           FORMAT 999G999        HEAD "Versions|Total"
COL VERSIONS         FORMAT A9             HEAD "Versions|Tot/Open"  JUST R
COL LOADED_VERSIONS  FORMAT 99G999G999     HEAD "Versões|Carregadas"
COL OPEN_VERSIONS    FORMAT 99G999G999     HEAD "Versões|Abertas"
COL PARSING_USER     FORMAT A20            HEAD "Parsing User"
COL CPU_TIME         FORMAT A12            HEAD 'CPU Time|msecs' JUST R
COL CPU_TIME_BY_EXEC FORMAT 999G999G999    HEAD 'CPU Time|msecs/Exec' JUST R
COL ELAPSED_TIME     FORMAT A12            HEAD 'Elapsed Time|msecs' JUST R
COL BIND_VAR         FORMAT A20            HEAD 'Bind name'
COL BIND_POS         FORMAT 999            HEAD 'Pos'
COL BIND_VALUE       FORMAT A100 TRUNC     HEAD 'Bind value'

COL P_HASH NEW_VALUE P_HASH NOPRINT
COL P_ADDR NEW_VALUE P_ADDR NOPRINT
COL P_CHILD_NUM NEW_VALUE P_CHILD_NUM NOPRINT
COL P_SQL_ID NEW_VALUE P_SQL_ID NOPRINT
COL VERSAO NEW_VALUE P_VERSAO NOPRINT
COL QTCOPIAS NEW_VALUE P_QTCOPIAS NOPRINT
COL WHERE_CURSOR NEW_VALUE P_WHERE_CURSOR NOPRINT

DEFINE P_HASH='0'
DEFINE P_ADDR='0'
DEFINE P_QTCOPIAS='-1'
DEFINE P_VERSAO=''
DEFINE P_WHERE_CURSOR=''
DEFINE P_SQL_ID=''

-- DEFINE A CLUSULA WHERE
SELECT 
  CASE UPPER(SUBSTR( '&P1.',1,5))
    WHEN '' THEN '1=0'
    WHEN 'HASH=' THEN 'S.HASH_VALUE = ' || SUBSTR( '&P1.',6, LENGTH('&P1.')) || ''
    WHEN 'ADDR=' THEN 'S.ADDRESS = ''' || SUBSTR( '&P1.',6, LENGTH('&P1.')) || ''''
    ELSE 'SQL_ID = ''&P1.'''
  END WHERE_CURSOR
FROM DUAL
/

-- DEFINE QUAL DOS ENDEREÇOS DE MEMÓRIA SERÁ USADO (MARCARÁ COM *)
SELECT 
   TO_CHAR(HASH_VALUE) P_HASH
  ,ADDRESS P_ADDR
  ,SQL_ID P_SQL_ID
  ,DECODE( TRUNC( (SELECT COUNT(*) FROM GV$SQL WHERE SQL_ID = S.SQL_ID) / 100 ), 0, 0, (SELECT COUNT(*) FROM GV$SQL WHERE SQL_ID = S.SQL_ID) )  QTCOPIAS
FROM GV$SQLAREA S
WHERE &P_WHERE_CURSOR.
ORDER BY OPEN_VERSIONS*1000 + USERS_OPENING DESC FETCH FIRST 1 ROW ONLY
/

-- VERIFICA O NUMERO DE COPIAS E VERSÃO DA ROTINA PARA OBTER O PLANO - CASO O NUMERO SEJA MUITO GRANT NEM RETORNA O PLANO (PROBLEMAS DE PERFORMANCE)
SELECT DECODE( &P_QTCOPIAS., '-1', '1', '0', SUBSTR( VERSION, 1, INSTR(VERSION, '.')-1), '' ) VERSAO
FROM GV$INSTANCE
/

SELECT MIN( CHILD_NUMBER ) P_CHILD_NUM
FROM GV$SQL_PLAN WHERE HASH_VALUE = &P_HASH. AND ADDRESS = '&P_ADDR.' 
/

-- COMEÇA A IMPRESSÃO DOS DADOS
SET TERMOUT ON

WITH GVSA AS 
(
  SELECT
     S.INST_ID
    ,S.SQL_ID
    ,S.ADDRESS
    ,LPAD(S.VERSION_COUNT||'/'||S.OPEN_VERSIONS, 9, ' ') VERSIONS 
    ,S.SORTS
    ,S.EXECUTIONS
    ,S.ROWS_PROCESSED
    ,S.DISK_READS
    ,ROUND(S.DISK_READS/DECODE(S.EXECUTIONS,0,1,S.EXECUTIONS),2) DR_EXEC
    ,S.BUFFER_GETS
    ,ROUND(S.BUFFER_GETS/DECODE(S.EXECUTIONS,0,1,S.EXECUTIONS),2) BG_EXEC
    ,S.CPU_TIME/1000 CPU_TIME
    ,S.CPU_TIME/1000/DECODE(S.EXECUTIONS,0,1,S.EXECUTIONS) CPU_TIME_BY_EXEC
    ,S.ELAPSED_TIME/1000 ELAPSED_TIME
  FROM GV$SQLAREA S
  WHERE &P_WHERE_CURSOR.
)
SELECT DISTINCT
   S.INST_ID SID
  ,DECODE( S.ADDRESS, '&P_ADDR', '* ', '  ' ) || S.ADDRESS ADDRESS
  --,V.HASH_VALUE
  ,S.EXECUTIONS
  ,S.SORTS
  ,S.ROWS_PROCESSED
  ,S.DISK_READS
  ,S.DR_EXEC
  ,S.BUFFER_GETS
  ,S.BG_EXEC
  ,LPAD(
     decode(sign(1e+12-S.CPU_TIME), -1, to_char(S.CPU_TIME/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.CPU_TIME), -1, to_char(S.CPU_TIME/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.CPU_TIME), -1, to_char(S.CPU_TIME/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.CPU_TIME, 'fm999g999g999' )  ) ) ), 12, ' ' ) CPU_TIME
  ,LPAD(
     decode(sign(1e+12-S.CPU_TIME_BY_EXEC), -1, to_char(S.CPU_TIME_BY_EXEC/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.CPU_TIME_BY_EXEC), -1, to_char(S.CPU_TIME_BY_EXEC/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.CPU_TIME_BY_EXEC), -1, to_char(S.CPU_TIME_BY_EXEC/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.CPU_TIME_BY_EXEC, 'fm999g999g999' )  ) ) ), 12, ' ' ) CPU_TIME_BY_EXEC
  ,LPAD(
     decode(sign(1e+12-S.ELAPSED_TIME), -1, to_char(S.ELAPSED_TIME/1e+09, 'fm999g999g999' ) || 'G',
     decode(sign(1e+09-S.ELAPSED_TIME), -1, to_char(S.ELAPSED_TIME/1e+06, 'fm999g999g999' ) || 'M',
     decode(sign(1e+06-S.ELAPSED_TIME), -1, to_char(S.ELAPSED_TIME/1e+03, 'fm999g999g999' ) || 'K',
     to_char(S.ELAPSED_TIME, 'fm999g999g999' )  ) ) ), 12, ' ' ) ELAPSED_TIME
  ,S.VERSIONS 
  ,LPAD(V.USERS_OPENING||'/'||V.USERS_EXECUTING, 9, ' ') USERS_OPENING
  --,V.PARSING_USER -- DECIDI OMITIR ESTA INFORMAÇÃO PARA LISTAR MENOS LINHAS
FROM GVSA S
LEFT JOIN 
(
  SELECT
    ADDRESS
   ,HASH_VALUE
   --,PARSING_SCHEMA_NAME PARSING_USER
   ,COUNT(*) CHILDS
   ,SUM( USERS_OPENING ) USERS_OPENING
   ,SUM( USERS_EXECUTING ) USERS_EXECUTING
  FROM GV$SQL S
  WHERE &P_WHERE_CURSOR.
  GROUP BY ADDRESS, HASH_VALUE /*, PARSING_SCHEMA_NAME */
) V ON (V.ADDRESS = S.ADDRESS)
WHERE &P_WHERE_CURSOR.
ORDER BY sid 
/

PROMPT
PROMPT --- Bind Info
SELECT POSITION BIND_POS, NAME BIND_VAR, VALUE_STRING BIND_VALUE
FROM V$SQL_BIND_CAPTURE S
WHERE &P_WHERE_CURSOR.
AND ADDRESS = '&P_ADDR.'
ORDER BY ADDRESS, CHILD_ADDRESS, POSITION
/
PROMPT
PROMPT --- <End> vBind Info

REM PROMPT DEBUG HASH: &P_HASH.
REM PROMPT DEBUG ADDRESS: &P_ADDR.
REM PROMPT DEBUG VERSAO = '&P_VERSAO.' COPIAS = &p_qtcopias.
REM PROMPT DEBUG WHERE_CURSOR &P_WHERE_CURSOR.

select /*+NO_MERGE(V) materialize*/ to_char(substr(sf,(level-1)*2000+1,2000)) sql_text
from (select sql_fulltext sf from v$sqlarea S
      WHERE &P_WHERE_CURSOR.
      AND ADDRESS = '&P_ADDR.'
     union all
     select sql_text from dba_hist_sqltext S
     WHERE &P_WHERE_CURSOR.
     and not exists (select 1 from v$sqlarea WHERE &P_WHERE_CURSOR.)) V
connect by level<=ceil(length(sf)/2000)
UNION ALL
SELECT '/' FROM DUAL
.

SET SERVEROUT ON
PROMPT
DECLARE
  -- ESTE BLOCO SERVE PARA RECUPERAR O TEXTO DE UM SQL
  NLEN    PLS_INTEGER ;
  IDX     PLS_INTEGER := 0;
  NPOS    PLS_INTEGER := 0;
  V_TXT   VARCHAR2(32000) := '';
  V_LINHA VARCHAR2(169) := '';

  FUNCTION RESERVADA( L VARCHAR2 ) RETURN NUMBER
  IS
    TYPE T IS TABLE OF VARCHAR2(30);
    A T := T( 'WITH', 'UPDATE', 'INSERT', 'DELETE', 'SELECT', 'FROM', 'WHERE', 'GROUP BY', 'HAVING',
               'ORDER BY', 'START WITH', 'CONNECT BY', 'VALUES', 'SET' );
    P PLS_INTEGER;
  BEGIN
    RETURN 0; -- INIBE ESTA FUNCAO
    FOR I IN A.FIRST .. A.LAST LOOP
       P := INSTR( L, A(I) );
       IF P > 2 THEN
         RETURN P-1;
       END IF;
    END LOOP;
    RETURN 0;
  END;

  FUNCTION WORDBREAK( L VARCHAR2 ) RETURN NUMBER
  IS
    A VARCHAR2(40) := '.,.=.>.<.).+.-.*./.';
    N PLS_INTEGER := LENGTH( L );
  BEGIN
    -- RETURN LENGTH(L); -- INIBE ESTA FUNCAO
    IF INSTR( L, CHR(10) ) > 0 THEN
      RETURN INSTR( L, CHR(10) );
    ELSIF N < 120 THEN
      RETURN N;
    ELSE
      FOR I IN REVERSE 1 .. LENGTH(L) LOOP
        IF INSTR( A, '.'||SUBSTR( L, I, 1 )||'.' ) > 0 THEN
          RETURN I;
        END IF;
      END LOOP;
    END IF;
    RETURN N;
  END;

BEGIN

  DBMS_OUTPUT.PUT_LINE( 'Comando de SQL' );
  DBMS_OUTPUT.PUT_LINE( LPAD( '~', 169, '~' ) );

  FOR C IN
  (
    SELECT SQL_TEXT FROM GV$SQLTEXT_WITH_NEWLINES S
    WHERE &P_WHERE_CURSOR. 
    AND ADDRESS = '&P_ADDR.'
    ORDER BY PIECE
  )
  LOOP
    V_TXT := V_TXT || C.SQL_TEXT;
  END LOOP;

  NLEN := LENGTH( V_TXT );

  WHILE IDX < NLEN LOOP

    V_LINHA := UPPER( SUBSTR( V_TXT, IDX+1, 169 ) );

    NPOS := RESERVADA( V_LINHA );

    IF NPOS = 0 THEN
      NPOS := WORDBREAK( V_LINHA );
    END IF;

    DBMS_OUTPUT.PUT_LINE( REPLACE(SUBSTR( V_TXT, IDX+1, NPOS ), CHR(10), '' ) );
    IDX := IDX + NPOS;

  END LOOP;

  IF LENGTH( V_TXT ) > 0 THEN
    DBMS_OUTPUT.PUT_LINE( '/' );
  ELSE
    DBMS_OUTPUT.PUT_LINE( 'Comando não encontrado!' );
  END IF;

END;
/

SET SERVEROUT OFF

PROMPT

SET PAGES 100 FEEDBACK 6 VERIFY ON UNDERLINE '-'

COL VERSAO CLEAR
COL QTCOPIAS CLEAR
COL ADDRESS CLEAR

UNDEFINE 1 P1 P_QTCOPIAS 

